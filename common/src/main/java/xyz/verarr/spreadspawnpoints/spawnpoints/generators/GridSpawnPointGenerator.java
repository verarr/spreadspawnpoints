package xyz.verarr.spreadspawnpoints.spawnpoints.generators;

import net.minecraft.nbt.NbtCompound;
import net.minecraft.server.world.ServerWorld;
import org.jetbrains.annotations.Contract;
import org.joml.Vector2i;
import xyz.verarr.spreadspawnpoints.spawnpoints.SpawnPointGenerator;

import java.util.HashSet;
import java.util.Set;

public class GridSpawnPointGenerator implements SpawnPointGenerator {
    public final Vector2i gridSize = new Vector2i(16);
    public final Vector2i offset = new Vector2i(0);

    private int currentX = 0;
    private int currentY = 0;
    private int direction = 0; // 0: right, 1: down, 2: left, 3: up
    private int stepsInCurrentDirection = 0;
    private int stepsInCurrentLayer = 1;

    public GridSpawnPointGenerator(ServerWorld serverWorld) {
        this.offset.set(
                serverWorld.getSpawnPos().getX(),
                serverWorld.getSpawnPos().getZ()
        );
    }

    /**
     * Generate a new spawnpoint and return it.
     *
     * @return the generated spawnpoint coordinates.
     */
    @Override
    public Vector2i next() {
        Vector2i vector = new Vector2i(currentX, currentY)
                .mul(gridSize)
                .add(offset);
        moveToNext();
        return vector;
    }

    /**
     * Spiral pattern algorithm
     */
    @Contract(mutates = "this")
    private void moveToNext() {
        switch (direction) {
            case 0: // Move right
                currentX++;
                break;
            case 1: // Move down
                currentY++;
                break;
            case 2: // Move left
                currentX--;
                break;
            case 3: // Move up
                currentY--;
                break;
        }

        stepsInCurrentDirection++;

        // Check if we need to change direction
        if (stepsInCurrentDirection == stepsInCurrentLayer) {
            direction = (direction + 1) % 4; // Change direction
            stepsInCurrentDirection = 0;

            // Increase the layer size after completing two directions
            if (direction == 0 || direction == 2) {
                stepsInCurrentLayer++;
            }
        }
    }

    /**
     * Test if a spawnpoint is valid, as in it may be generated by this generator.
     *
     * @param spawnPoint spawnpoint to test
     * @return true if the spawnpoint may be generated by this generator, false otherwise.
     */
    @Override
    public boolean isValid(Vector2i spawnPoint) {
        return (
                (spawnPoint.x - offset.x) % gridSize.x == 0 &&
                        (spawnPoint.y - offset.y) % gridSize.y == 0
        );
    }

    /**
     * This method is ignored.
     */
    @Override
    public void add(Vector2i spawnPoint) {}

    /**
     * This method is ignored.
     */
    @Override
    public void remove(Vector2i spawnPoint) {}

    @Override
    public NbtCompound writeNbt() {
        NbtCompound nbt = new NbtCompound();
        nbt.putInt("gridX", gridSize.x);
        nbt.putInt("gridZ", gridSize.y);
        nbt.putInt("offsetX", offset.x);
        nbt.putInt("offsetZ", offset.y);

        NbtCompound state = new NbtCompound();
        state.putInt("currentX", currentX);
        state.putInt("currentZ", currentY);
        state.putInt("direction", direction);
        state.putInt("stepsInCurrentDirection", stepsInCurrentDirection);
        state.putInt("stepsInCurrentLayer", stepsInCurrentLayer);
        nbt.put("state", state);

        return nbt;
    }

    @Override
    public void modifyFromNbt(NbtCompound tag) {
        gridSize.x = tag.getInt("gridX");
        gridSize.y = tag.getInt("gridZ");
        offset.x = tag.getInt("offsetX");
        offset.y = tag.getInt("offsetZ");

        NbtCompound state = tag.getCompound("state");
        currentX = state.getInt("currentX");
        currentY = state.getInt("currentZ");
        direction = state.getInt("direction");
        stepsInCurrentDirection = state.getInt("stepsInCurrentDirection");
        stepsInCurrentLayer = state.getInt("stepsInCurrentLayer");
    }

    @Override
    public void modifyFromNbtPartial(NbtCompound tag) throws IllegalArgumentException {
        Set<String> differenceSet = new HashSet<>(tag.getKeys());
        differenceSet.removeAll(Set.of("gridX", "gridZ", "offsetX", "offsetZ"));
        if (!differenceSet.isEmpty())
            throw new IllegalArgumentException("Invalid tag keys: " + differenceSet.stream().reduce((a, b) -> a + ", " + b).orElse("(none)"));

        if (tag.contains("gridX") && tag.getType("gridX") != 3) throw new IllegalArgumentException("gridX must be an integer");
        if (tag.contains("gridZ") && tag.getType("gridZ") != 3) throw new IllegalArgumentException("gridZ must be an integer");
        if (tag.contains("offsetX") && tag.getType("offsetX") != 3) throw new IllegalArgumentException("offsetX must be an integer");
        if (tag.contains("offsetZ") && tag.getType("offsetZ") != 3) throw new IllegalArgumentException("offsetZ must be an integer");

        if (tag.contains("gridX", 3))
            gridSize.x = tag.getInt("gridX");
        if (tag.contains("gridZ", 3))
            gridSize.y = tag.getInt("gridZ");
        if (tag.contains("offsetX", 3))
            offset.x = tag.getInt("offsetX");
        if (tag.contains("offsetZ", 3))
            offset.y = tag.getInt("offsetZ");
    }
}
