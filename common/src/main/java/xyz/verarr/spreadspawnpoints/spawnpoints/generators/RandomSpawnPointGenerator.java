package xyz.verarr.spreadspawnpoints.spawnpoints.generators;

import net.minecraft.nbt.NbtCompound;
import net.minecraft.server.world.ServerWorld;
import net.minecraft.util.Pair;
import net.minecraft.util.math.random.LocalRandom;
import net.minecraft.util.math.random.Random;
import net.minecraft.world.border.WorldBorder;
import org.joml.Vector2i;
import xyz.verarr.spreadspawnpoints.mixin.LocalRandomAccessor;
import xyz.verarr.spreadspawnpoints.spawnpoints.SpawnPointGenerator;

public class RandomSpawnPointGenerator implements SpawnPointGenerator {
    private Pair<Vector2i, Vector2i> bounds;
    private Random random;

    public RandomSpawnPointGenerator(ServerWorld serverWorld) {
        WorldBorder border = serverWorld.getWorldBorder();
        Vector2i lowerBounds = new Vector2i((int) border.getBoundWest(), (int) border.getBoundNorth());
        Vector2i upperBounds = new Vector2i((int) border.getBoundEast(), (int) border.getBoundSouth());
        this.bounds = new Pair<>(lowerBounds, upperBounds);
        this.random = new LocalRandom(serverWorld.getSeed());
    }

    /**
     * Set the bounds in which the spawnpoints will be generated.
     *
     * @param bounds lower bound followed by upper bound.
     */
    public void setBounds(Pair<Vector2i, Vector2i> bounds) {
        this.bounds = bounds;
    }

    /**
     * Generate a new spawnpoint and return it.
     *
     * @return the generated spawnpoint coordinates.
     */
    @Override
    public Vector2i next() {
        return new Vector2i(
                random.nextBetween(bounds.getLeft().x, bounds.getRight().x),
                random.nextBetween(bounds.getLeft().y, bounds.getRight().y)
        );
    }

    /**
     * Test if a spawnpoint is valid, as in it may be generated by this generator.
     *
     * @param spawnPoint spawnpoint to test
     * @return true if the spawnpoint may be generated by this generator, false otherwise.
     */
    @Override
    public boolean isValid(Vector2i spawnPoint) {
        return (
                bounds.getLeft().x <= spawnPoint.x &&
                        bounds.getRight().x >= spawnPoint.x &&
                        bounds.getLeft().y <= spawnPoint.y &&
                        bounds.getRight().y >= spawnPoint.y
        );
    }

    /**
     * This method is ignored.
     */
    @Override
    public void add(Vector2i spawnPoint) {}

    /**
     * This method is ignored.
     */
    @Override
    public void remove(Vector2i spawnPoint) {}

    // NBTSerializable stuff
    @Override
    public NbtCompound writeNbt() {
        NbtCompound nbt = new NbtCompound();
        nbt.putInt("lowerX", bounds.getLeft().x);
        nbt.putInt("upperX", bounds.getRight().x);
        nbt.putInt("lowerZ", bounds.getLeft().y);
        nbt.putInt("upperZ", bounds.getRight().y);
        nbt.putLong("seed", ((LocalRandomAccessor) random).getSeed());
        return nbt;
    }

    @Override
    public void modifyFromNbt(NbtCompound tag) {
        Vector2i lowerBounds = new Vector2i(
                tag.getInt("lowerX"),
                tag.getInt("lowerZ")
        );
        Vector2i upperBounds = new Vector2i(
                tag.getInt("upperX"),
                tag.getInt("upperZ")
        );
        setBounds(new Pair<>(lowerBounds, upperBounds));
        random = new LocalRandom(tag.getLong("seed"));
    }

    @Override
    public void modifyFromNbtPartial(NbtCompound tag) {
        Vector2i lowerBounds = bounds.getLeft();
        Vector2i upperBounds = bounds.getRight();
        if (tag.contains("lowerX", 3))
            lowerBounds.x = tag.getInt("lowerX");
        if (tag.contains("lowerZ", 3))
            lowerBounds.y = tag.getInt("lowerZ");
        if (tag.contains("upperX", 3))
            upperBounds.x = tag.getInt("upper");
        if (tag.contains("upperZ", 3))
            upperBounds.y = tag.getInt("upperZ");
        setBounds(new Pair<>(lowerBounds, upperBounds));

        if (tag.contains("seed", 4))
            random.setSeed(tag.getLong("seed"));
    }
}
